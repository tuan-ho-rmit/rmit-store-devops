- hosts: localhost
  connection: local
  gather_facts: no
  vars:
    aws_region: "{{ lookup('env','AWS_REGION') | default('us-east-1', true) }}"
    key_name: "{{ lookup('env','EC2_KEY_NAME') }}"
    skip_keypair: "{{ lookup('env','SKIP_KEYPAIR') | default('0', true) }}"
    skip_ami_lookup: "{{ lookup('env','SKIP_AMI_LOOKUP') | default('0', true) }}"
    ami_id: "{{ lookup('env','AMI_ID') | default('', true) }}"
    type_jenkins: "{{ lookup('env','TYPE_JENKINS') | default('t3.micro', true) }}"
    type_master:  "{{ lookup('env','TYPE_MASTER')  | default('t3.micro', true) }}"
    type_worker:  "{{ lookup('env','TYPE_WORKER')  | default('t3.micro', true) }}"
    type_mongo:   "{{ lookup('env','TYPE_MONGO')   | default('t3.micro', true) }}"
    ami_param:    "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64"
    skip_eip:     "{{ lookup('env','SKIP_EIP') | default('0', true) }}"
    ssh_cidr_env: "{{ lookup('env','SSH_CIDR') | default('', true) }}"
    # Root volume sizes (GiB)
    jenkins_root_gb: "{{ lookup('env','JENKINS_ROOT_GB') | default('60', true) }}"
    default_root_gb: "{{ lookup('env','DEFAULT_ROOT_GB') | default('16', true) }}"

  collections:
    - amazon.aws

  tasks:
    - name: Detect controller public IP (for SSH CIDR) when SSH_CIDR not provided
      uri:
        url: https://api.ipify.org
        method: GET
        return_content: yes
        validate_certs: no
      register: ipify
      when: ssh_cidr_env | length == 0

    - name: Set ssh_cidr fact
      set_fact:
        ssh_cidr: "{{ (ssh_cidr_env if (ssh_cidr_env | length) > 0 else ipify.content) ~ '/32' }}"
    - name: Fail fast if EC2_KEY_NAME is not set
      assert:
        that:
          - key_name | length > 0
        fail_msg: "EC2_KEY_NAME is empty. Set it in .env or export EC2_KEY_NAME before running make up."

    - name: Ensure key pair exists (create if missing)
      when: skip_keypair != '1'
      amazon.aws.ec2_key:
        name: "{{ key_name }}"
        state: present
        region: "{{ aws_region }}"
      register: created_key

    - name: Write downloaded private key to file (0400)
      when: skip_keypair != '1' and created_key is defined and created_key.changed | default(false) and (created_key.key is defined) and (created_key.key.private_key is defined)
      copy:
        dest: "{{ playbook_dir }}/../{{ key_name }}.pem"
        content: "{{ created_key.key.private_key }}"
        mode: '0400'

    - name: AMI lookup via SSM (skip with SKIP_AMI_LOOKUP=1)
      when: skip_ami_lookup != '1' and (ami_id | length) == 0
      command: >-
        aws ssm get-parameters --region {{ aws_region }} --names {{ ami_param }} --query 'Parameters[0].Value' --output text
      register: ssm_ami
      changed_when: false

    - name: Set AMI from SSM result
      when: skip_ami_lookup != '1' and (ami_id | length) == 0
      set_fact:
        ami_id: "{{ ssm_ami.stdout }}"

    - name: Ensure AMI_ID provided when skipping lookup
      when: skip_ami_lookup == '1'
      assert:
        that:
          - ami_id | length > 0
        fail_msg: "AMI_ID must be set when SKIP_AMI_LOOKUP=1"

    - name: Create VPC
      amazon.aws.ec2_vpc_net:
        name: rmit-vpc
        cidr_block: 10.10.0.0/16
        region: "{{ aws_region }}"
        dns_hostnames: true
        dns_support: true
        state: present
      register: vpc

    - name: Create Internet Gateway
      amazon.aws.ec2_vpc_igw:
        vpc_id: "{{ vpc.vpc.id }}"
        region: "{{ aws_region }}"
        state: present
      register: igw

    - name: Create public subnets
      amazon.aws.ec2_vpc_subnet:
        vpc_id: "{{ vpc.vpc.id }}"
        cidr: "{{ item.cidr }}"
        az: "{{ item.az }}"
        map_public: true
        state: present
        region: "{{ aws_region }}"
      loop:
        - { cidr: '10.10.1.0/24', az: '{{ aws_region }}a' }
        - { cidr: '10.10.2.0/24', az: '{{ aws_region }}b' }
      register: subnets

    - name: Create route table and default route
      amazon.aws.ec2_vpc_route_table:
        vpc_id: "{{ vpc.vpc.id }}"
        region: "{{ aws_region }}"
        subnets:
          - "{{ (subnets.results[0].subnet.id) }}"
          - "{{ (subnets.results[1].subnet.id) }}"
        routes:
          - dest: 0.0.0.0/0
            gateway_id: "{{ igw.gateway_id }}"
        tags:
          Name: rmit-public-rt

    - name: Create Security Groups
      amazon.aws.ec2_group:
        name: "{{ item.name }}"
        description: "{{ item.desc }}"
        vpc_id: "{{ vpc.vpc.id }}"
        region: "{{ aws_region }}"
        rules: "{{ item.rules }}"
        state: present
      loop:
        - name: rmit-jenkins-sg
          desc: Jenkins
          rules:
            - proto: tcp
              from_port: 22
              to_port: 22
              cidr_ip: 0.0.0.0/0
            - proto: tcp
              from_port: 8080
              to_port: 8080
              cidr_ip: 0.0.0.0/0
        - name: rmit-master-sg
          desc: k3s-master
          rules:
            - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: 0.0.0.0/0 }
            - { proto: tcp, from_port: 80, to_port: 80, cidr_ip: 0.0.0.0/0 }
            - { proto: tcp, from_port: 443, to_port: 443, cidr_ip: 0.0.0.0/0 }
            # k3s apiserver from VPC
            - { proto: tcp, from_port: 6443, to_port: 6443, cidr_ip: 10.10.0.0/16 }
            # flannel VXLAN between nodes
            - { proto: udp, from_port: 8472, to_port: 8472, cidr_ip: 10.10.0.0/16 }
            # kubelet metrics/exec from control-plane
            - { proto: tcp, from_port: 10250, to_port: 10250, cidr_ip: 10.10.0.0/16 }
        - name: rmit-worker-sg
          desc: k3s-workers
          rules:
            - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: 0.0.0.0/0 }
            # flannel VXLAN between nodes
            - { proto: udp, from_port: 8472, to_port: 8472, cidr_ip: 10.10.0.0/16 }
            # kubelet metrics/exec from control-plane
            - { proto: tcp, from_port: 10250, to_port: 10250, cidr_ip: 10.10.0.0/16 }
        - name: rmit-mongo-sg
          desc: Mongo-only-from-cluster
          rules:
            - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: "{{ ssh_cidr }}" }
            - { proto: tcp, from_port: 27017, to_port: 27017, cidr_ip: 10.10.0.0/16 }

    - name: Launch EC2 instances
      amazon.aws.ec2_instance:
        name: "{{ item.name }}"
        region: "{{ aws_region }}"
        key_name: "{{ key_name }}"
        instance_type: "{{ item.type }}"
        image_id: "{{ ami_id }}"
        network:
          assign_public_ip: true
        vpc_subnet_id: "{{ item.subnet }}"
        security_group: "{{ item.sg }}"
        wait: true
        volumes:
          - device_name: /dev/xvda
            ebs:
              volume_type: gp3
              volume_size: "{{ (item.name == 'jenkins') | ternary(jenkins_root_gb | int, default_root_gb | int) }}"
              delete_on_termination: true
      loop:
        - { name: jenkins,      type: '{{ type_jenkins }}', subnet: '{{ (subnets.results[0].subnet.id) }}', sg: 'rmit-jenkins-sg' }
        - { name: k3s-master,   type: '{{ type_master  }}', subnet: '{{ (subnets.results[0].subnet.id) }}', sg: 'rmit-master-sg' }
        - { name: k3s-client,   type: '{{ type_worker  }}', subnet: '{{ (subnets.results[1].subnet.id) }}', sg: 'rmit-worker-sg' }
        - { name: k3s-server,   type: '{{ type_worker  }}', subnet: '{{ (subnets.results[1].subnet.id) }}', sg: 'rmit-worker-sg' }
        - { name: mongo,        type: '{{ type_mongo   }}', subnet: '{{ (subnets.results[0].subnet.id) }}', sg: 'rmit-mongo-sg' }
      register: ec2

    - name: Capture instance IDs for EIP association
      set_fact:
        jenkins_id: "{{ ec2.results[0].instances[0].instance_id }}"
        master_id:  "{{ ec2.results[1].instances[0].instance_id }}"
        client_id:  "{{ ec2.results[2].instances[0].instance_id }}"
        server_id:  "{{ ec2.results[3].instances[0].instance_id }}"
        mongo_id:   "{{ ec2.results[4].instances[0].instance_id }}"

    - name: Allocate and associate Elastic IP for Jenkins
      amazon.aws.ec2_eip:
        state: present
        region: "{{ aws_region }}"
        in_vpc: true
        device_id: "{{ jenkins_id }}"
        reuse_existing_ip_allowed: true
      register: eip_jenkins
      when: skip_eip != '1'

    - name: Allocate and associate Elastic IP for k3s-master
      amazon.aws.ec2_eip:
        state: present
        region: "{{ aws_region }}"
        in_vpc: true
        device_id: "{{ master_id }}"
        reuse_existing_ip_allowed: true
      register: eip_master
      when: skip_eip != '1'

    - name: Allocate and associate Elastic IP for k3s-client
      amazon.aws.ec2_eip:
        state: present
        region: "{{ aws_region }}"
        in_vpc: true
        device_id: "{{ client_id }}"
        reuse_existing_ip_allowed: true
      register: eip_client
      when: skip_eip != '1'

    - name: Allocate and associate Elastic IP for k3s-server
      amazon.aws.ec2_eip:
        state: present
        region: "{{ aws_region }}"
        in_vpc: true
        device_id: "{{ server_id }}"
        reuse_existing_ip_allowed: true
      register: eip_server
      when: skip_eip != '1'

    - name: Allocate and associate Elastic IP for mongo
      amazon.aws.ec2_eip:
        state: present
        region: "{{ aws_region }}"
        in_vpc: true
        device_id: "{{ mongo_id }}"
        reuse_existing_ip_allowed: true
      register: eip_mongo
      when: skip_eip != '1'

    - name: Determine public IPs to write (prefer EIP)
      set_fact:
        jenkins_pub_ip: "{{ (eip_jenkins | default({})).public_ip | default(ec2.results[0].instances[0].public_ip_address) }}"
        master_pub_ip:  "{{ (eip_master  | default({})).public_ip | default(ec2.results[1].instances[0].public_ip_address) }}"
        client_pub_ip:  "{{ (eip_client  | default({})).public_ip | default(ec2.results[2].instances[0].public_ip_address) }}"
        server_pub_ip:  "{{ (eip_server  | default({})).public_ip | default(ec2.results[3].instances[0].public_ip_address) }}"
        mongo_pub_ip:   "{{ (eip_mongo   | default({})).public_ip | default(ec2.results[4].instances[0].public_ip_address) }}"

    - name: Build outputs env file
      copy:
        dest: "{{ playbook_dir }}/ec2-outputs.env"
        content: |
          JenkinsIP={{ jenkins_pub_ip }}
          MasterIP={{  master_pub_ip  }}
          ClientIP={{  client_pub_ip }}
          ServerIP={{  server_pub_ip }}
          MongoIPPub={{ mongo_pub_ip }}
          JenkinsPriv={{ (ec2.results[0].instances[0].private_ip_address) }}
          MasterPriv={{  (ec2.results[1].instances[0].private_ip_address) }}
          ClientPriv={{  (ec2.results[2].instances[0].private_ip_address) }}
          ServerPriv={{  (ec2.results[3].instances[0].private_ip_address) }}
          MongoPriv={{   (ec2.results[4].instances[0].private_ip_address) }}


