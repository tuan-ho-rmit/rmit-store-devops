- name: Create Jenkins config dir
  file: { path: /opt/jenkins, state: directory, mode: '0755' }

- name: Ensure Jenkins home dir exists
  file:
    path: /var/jenkins_home
    state: directory
    owner: 1000
    group: 1000
    mode: '0775'
    recurse: yes

- name: Stop Jenkins container if running (to fix perms)
  docker_container:
    name: jenkins
    state: stopped
  ignore_errors: true

# --- Auto-expand root partition and filesystem (idempotent) ---
- name: Install growpart and FS tools
  package:
    name:
      - cloud-utils-growpart
      - xfsprogs
      - e2fsprogs
    state: present
  become: true

- name: Detect root device and filesystem
  shell: |
    set -e
    ROOT=$(findmnt -n -o SOURCE /)
    FSTYPE=$(findmnt -n -o FSTYPE /)
    if echo "$ROOT" | grep -q nvme; then
      DISK="/dev/$(basename "$ROOT" | sed -E 's/p[0-9]+$//')"
      PARTNUM=$(basename "$ROOT" | sed -E 's/^.*p([0-9]+)$/\1/')
      PARTPATH="${DISK}p${PARTNUM}"
    else
      DISK="/dev/$(basename "$ROOT" | sed -E 's/[0-9]+$//')"
      PARTNUM=$(basename "$ROOT" | sed -E 's/^.*([0-9]+)$/\1/')
      PARTPATH="${DISK}${PARTNUM}"
    fi
    echo DISK=$DISK
    echo PARTNUM=$PARTNUM
    echo PARTPATH=$PARTPATH
    echo FSTYPE=$FSTYPE
  args: { executable: /bin/bash }
  register: root_detect
  changed_when: false

- name: Set facts from detection
  set_fact:
    root_disk: "{{ root_detect.stdout_lines | select('match','^DISK=') | list | first | regex_replace('^DISK=','') }}"
    root_partnum: "{{ root_detect.stdout_lines | select('match','^PARTNUM=') | list | first | regex_replace('^PARTNUM=','') }}"
    root_partpath: "{{ root_detect.stdout_lines | select('match','^PARTPATH=') | list | first | regex_replace('^PARTPATH=','') }}"
    root_fstype: "{{ root_detect.stdout_lines | select('match','^FSTYPE=') | list | first | regex_replace('^FSTYPE=','') }}"

- name: Grow partition (no-op if already max)
  shell: "growpart {{ root_disk }} {{ root_partnum }}"
  become: true
  register: growpart_res
  failed_when: growpart_res.rc not in [0,1]
  changed_when: growpart_res.rc == 0

- name: Grow filesystem (XFS)
  shell: xfs_growfs -d /
  when: root_fstype == 'xfs'
  become: true

- name: Grow filesystem (ext4)
  shell: "resize2fs {{ root_partpath }}"
  when: root_fstype == 'ext4'
  become: true
# --- end auto-expand ---

- name: Write plugins.txt
  copy:
    dest: /opt/jenkins/plugins.txt
    content: |
      git
      workflow-aggregator
      blueocean
      docker-workflow
      email-ext
      timestamper
      configuration-as-code
      kubernetes-cli
      github
      github-branch-source
      # minimal set to avoid boot-time plugin dependency issues

- name: Read kubeconfig from k3s master (fallback if fact missing)
  slurp:
    src: /home/ec2-user/kubeconfig.yaml
  delegate_to: "{{ groups['k3s_master'][0] }}"
  run_once: true
  register: kubeconf_remote
  ignore_errors: true

- name: Choose kubeconfig_b64 value (fact first, then remote file)
  set_fact:
    kubeconfig_b64_effective: "{{ hostvars[groups['k3s_master'][0]].kubeconfig_b64 | default(kubeconf_remote.content | default('')) }}"

- name: Render casc.yaml from template (inject secrets)
  template:
    src: "{{ playbook_dir }}/../jenkins/casc.yaml.j2"
    dest: /opt/jenkins/casc.yaml
    mode: '0644'
  vars:
    kubeconfig_b64: "{{ kubeconfig_b64_effective | default('') }}"

- name: Run Jenkins container
  docker_container:
    name: jenkins
    image: jenkins/jenkins:lts
    restart_policy: unless-stopped
    state: started
    published_ports: ["8080:8080","50000:50000"]
    volumes:
      - /var/jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
      - /opt/jenkins:/config
    env:
      CASC_JENKINS_CONFIG: /config/casc.yaml
      JAVA_OPTS: "-Xms256m -Xmx512m -Djenkins.install.runSetupWizard=false"

- name: Install Docker CLI inside Jenkins container
  shell: |
    set -e
    docker exec -u 0 jenkins bash -lc 'apt-get update -y && (apt-get install -y docker.io || apt-get install -y docker-cli || apt-get install -y docker-ce-cli)'
    docker exec jenkins docker --version
  register: docker_cli_install
  changed_when: true

- name: Get docker group gid on host
  shell: "getent group docker | cut -d':' -f3"
  register: docker_gid
  changed_when: false

- name: Map docker group into container and add jenkins user to it
  shell: |
    set -e
    DOCKER_GID="{{ docker_gid.stdout }}"
    docker exec -u 0 jenkins bash -lc '
      set -e
      if getent group docker >/dev/null 2>&1; then
        groupmod -o -g '"$DOCKER_GID"' docker || true;
      else
        groupadd -g '"$DOCKER_GID"' docker || true;
      fi
      usermod -aG docker jenkins
    '
    # show membership
    docker exec jenkins id jenkins
  when: docker_gid.stdout | length > 0

- name: Wait until Jenkins container is running (not restarting)
  shell: |
    set -e
    docker inspect --format "{{'{{'}}.State.Running{{'}}'}} {{'{{'}}.State.Restarting{{'}}'}}" jenkins 2>/dev/null | grep -q "^true false$"
  register: jenkins_running
  retries: 30
  delay: 5
  until: jenkins_running.rc == 0
  changed_when: false

- name: Diagnostics when Jenkins is not healthy
  shell: |
    echo '--- docker ps:'
    docker ps -a --filter name=jenkins
    echo '--- inspect:'
    docker inspect jenkins | sed -n '1,120p'
    echo '--- last 200 logs:'
    docker logs --tail=200 jenkins | sed -n '1,200p'
  when: jenkins_running is failed
  register: jenkins_diag
  failed_when: false
  changed_when: false
  ignore_errors: true

- name: Show Jenkins diagnostics
  debug:
    var: jenkins_diag.stdout_lines
  when: jenkins_diag is defined

- name: Install plugins via CLI
  shell: docker exec jenkins jenkins-plugin-cli -f /config/plugins.txt
  register: plugin_cli
  retries: 8
  delay: 10
  until: plugin_cli.rc == 0

- name: Ensure RMIT-Store job dir exists on disk
  file:
    path: /var/jenkins_home/jobs/RMIT-Store
    state: directory
    owner: 1000
    group: 1000
    mode: '0775'

- name: Write RMIT-Store job config.xml on disk (deterministic creation)
  copy:
    dest: /var/jenkins_home/jobs/RMIT-Store/config.xml
    owner: 1000
    group: 1000
    mode: '0644'
    content: |
      <flow-definition plugin="workflow-job">
        <description>CI/CD pipeline for RMIT Store (on-disk)</description>
        <keepDependencies>false</keepDependencies>
        <triggers>
          <com.cloudbees.jenkins.GitHubPushTrigger plugin="github"/>
        </triggers>
        <definition class="org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition" plugin="workflow-cps">
          <scm class="hudson.plugins.git.GitSCM" plugin="git">
            <userRemoteConfigs>
              <hudson.plugins.git.UserRemoteConfig>
                <url>{{ github_repo }}</url>
                <credentialsId>github-token</credentialsId>
              </hudson.plugins.git.UserRemoteConfig>
            </userRemoteConfigs>
            <branches>
              <hudson.plugins.git.BranchSpec>
                <name>*/main</name>
              </hudson.plugins.git.BranchSpec>
            </branches>
          </scm>
          <scriptPath>Jenkinsfile</scriptPath>
          <lightweight>true</lightweight>
        </definition>
        <disabled>false</disabled>
      </flow-definition>

- name: Stat RMIT-Store job config
  stat:
    path: /var/jenkins_home/jobs/RMIT-Store/config.xml
  register: job_cfg

- name: Restart Jenkins to load plugins + JCasC
  docker_container:
    name: jenkins
    restart: yes

- name: Wait for Jenkins HTTP to respond
  shell: |
    for i in $(seq 1 60); do
      code=$(curl -s -m 3 -o /dev/null -w '%{http_code}' http://localhost:8080/login || true);
      if [ "$code" = "200" ]; then exit 0; fi; sleep 2;
    done; exit 1
  register: jenkins_http_ready
  retries: 1
  delay: 0
  changed_when: false

- name: Render RMIT-Store pipeline job XML (REST)
  copy:
    dest: /opt/jenkins/job-rmit-store.xml
    mode: '0644'
    content: |
      <flow-definition plugin="workflow-job">
        <description>CI/CD pipeline for RMIT Store</description>
        <keepDependencies>false</keepDependencies>
        <triggers>
          <com.cloudbees.jenkins.GitHubPushTrigger plugin="github"/>
        </triggers>
        <definition class="org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition" plugin="workflow-cps">
          <scm class="hudson.plugins.git.GitSCM" plugin="git">
            <userRemoteConfigs>
              <hudson.plugins.git.UserRemoteConfig>
                <url>{{ github_repo }}</url>
                <credentialsId>github-token</credentialsId>
              </hudson.plugins.git.UserRemoteConfig>
            </userRemoteConfigs>
            <branches>
              <hudson.plugins.git.BranchSpec><name>*/main</name></hudson.plugins.git.BranchSpec>
            </branches>
          </scm>
          <scriptPath>Jenkinsfile</scriptPath>
          <lightweight>true</lightweight>
        </definition>
      </flow-definition>

- name: Check if RMIT-Store job exists
  shell: |
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    curl -s -u "$ADMIN:$PASS" -o /dev/null -w '%{http_code}' http://localhost:8080/job/RMIT-Store/api/json || true
  register: job_exists
  changed_when: false

- name: Download Jenkins CLI inside container (if job missing)
  shell: |
    set -e
    docker exec jenkins bash -lc "curl -fsSL -o /opt/cli.jar http://localhost:8080/jnlpJars/cli.jar && ls -l /opt/cli.jar"
  register: cli_dl
  changed_when: true
  when: job_exists.stdout != '200' and (job_cfg is not defined or not job_cfg.stat.exists)

- name: Create RMIT-Store job via CLI (inside container)
  shell: |
    set -e
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    docker exec -i jenkins bash -lc "java -jar /opt/cli.jar -s http://localhost:8080 -auth \"$ADMIN:$PASS\" create-job RMIT-Store < /config/job-rmit-store.xml"
  register: cli_create
  changed_when: true
  when: job_exists.stdout != '200' and (job_cfg is not defined or not job_cfg.stat.exists)
  args:
    executable: /bin/bash
  ignore_errors: true

- name: Create RMIT-Store job via REST
  shell: |
    set -e
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    CJ=$(mktemp /tmp/jenkins_cj.XXXXXX)
    # Fetch crumb and session cookie
    JSON=$(curl -s -u "$ADMIN:$PASS" -c "$CJ" "http://localhost:8080/crumbIssuer/api/json")
    CRUMB_FIELD=$(echo "$JSON" | sed -n 's/.*"crumbRequestField":"\([^"]*\)".*/\1/p')
    CRUMB_VALUE=$(echo "$JSON" | sed -n 's/.*"crumb":"\([^"]*\)".*/\1/p')
    CODE=$(curl -s -o /tmp/job_create.out -w '%{http_code}' \
      -u "$ADMIN:$PASS" -b "$CJ" -H "$CRUMB_FIELD: $CRUMB_VALUE" -H 'Content-Type: application/xml' \
      -X POST --data-binary @/opt/jenkins/job-rmit-store.xml \
      'http://localhost:8080/createItem?name=RMIT-Store' || true)
    echo "createItem HTTP_CODE=$CODE"
    if [ "$CODE" != "200" ] && [ "$CODE" != "302" ]; then
      echo '--- response (head) ---'; head -n 80 /tmp/job_create.out || true
      exit 17
    fi
    rm -f "$CJ"
  when: job_exists.stdout != '200' and (job_cfg is not defined or not job_cfg.stat.exists)
  changed_when: true
  args:
    executable: /bin/bash

- name: Wait until RMIT-Store job is visible (verify)
  shell: |
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    curl -s -u "$ADMIN:$PASS" -o /dev/null -w '%{http_code}' http://localhost:8080/job/RMIT-Store/api/json
  register: job_ready
  retries: 10
  delay: 3
  until: job_ready.stdout == '200'
  changed_when: false

- name: List Jenkins jobs for diagnostics
  shell: |
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    curl -s -u "$ADMIN:$PASS" 'http://localhost:8080/api/json?tree=jobs[name]'
  register: jobs_list
  changed_when: false
  failed_when: false
  ignore_errors: true

- name: Show jobs list
  debug:
    var: jobs_list.stdout
  when: jobs_list is defined

- name: Compute GitHub webhook URL
  set_fact:
    gh_webhook_url: "{{ jenkins_url_hint | regex_replace('/?$', '/') }}github-webhook/"

- name: Compute sanitized repo name for GitHub API
  set_fact:
    gh_repo_name: "{{ (github_repo | regex_replace('.*/','') | regex_replace('\\.git$','')) }}"

- name: List existing GitHub webhooks
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ gh_repo_name }}/hooks"
    method: GET
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    return_content: true
  register: gh_hooks
  changed_when: false

- name: Check if webhook exists
  set_fact:
    gh_hook: "{{ (gh_hooks.json | selectattr('config.url','equalto', gh_webhook_url) | list | first) | default(None) }}"

- name: Ensure GitHub webhook exists (create if missing)
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ gh_repo_name }}/hooks"
    method: POST
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    status_code: [201, 422]
    body_format: json
    body:
      name: web
      active: true
      events: [push]
      config:
        url: "{{ gh_webhook_url }}"
        content_type: json
        insecure_ssl: "0"
  register: gh_create

- name: Determine webhook id
  set_fact:
    gh_hook_id: "{{ (gh_hook.id | default('')) if (gh_hook is defined and gh_hook is not none) else (gh_create.json.id | default('')) }}"

- name: Ping webhook
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ gh_repo_name }}/hooks/{{ gh_hook_id }}/pings"
    method: POST
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    status_code: 204
  changed_when: false
  when: gh_hook_id is defined and gh_hook_id | length > 0
