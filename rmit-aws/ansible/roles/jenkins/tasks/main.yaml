- name: Create Jenkins config dir
  file: { path: /opt/jenkins, state: directory, mode: '0755' }

- name: Ensure Jenkins home dir exists
  file:
    path: /var/jenkins_home
    state: directory
    owner: 1000
    group: 1000
    mode: '0775'
    recurse: yes

- name: Stop Jenkins container if running (to fix perms)
  docker_container:
    name: jenkins
    state: stopped
  ignore_errors: true

- name: Write plugins.txt
  copy:
    dest: /opt/jenkins/plugins.txt
    content: |
      git
      workflow-aggregator
      blueocean
      docker-workflow
      email-ext
      configuration-as-code
      kubernetes-cli
      github
      github-branch-source
      # minimal set to avoid boot-time plugin dependency issues

- name: Read kubeconfig from k3s master (fallback if fact missing)
  slurp:
    src: /home/ec2-user/kubeconfig.yaml
  delegate_to: "{{ groups['k3s_master'][0] }}"
  run_once: true
  register: kubeconf_remote
  ignore_errors: true

- name: Choose kubeconfig_b64 value (fact first, then remote file)
  set_fact:
    kubeconfig_b64_effective: "{{ hostvars[groups['k3s_master'][0]].kubeconfig_b64 | default(kubeconf_remote.content | default('')) }}"

- name: Render casc.yaml from template (inject secrets)
  template:
    src: "{{ playbook_dir }}/../jenkins/casc.yaml.j2"
    dest: /opt/jenkins/casc.yaml
    mode: '0644'
  vars:
    kubeconfig_b64: "{{ kubeconfig_b64_effective | default('') }}"

- name: Run Jenkins container
  docker_container:
    name: jenkins
    image: jenkins/jenkins:lts
    restart_policy: unless-stopped
    state: started
    published_ports: ["8080:8080","50000:50000"]
    volumes:
      - /var/jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
      - /opt/jenkins:/config
    env:
      CASC_JENKINS_CONFIG: /config/casc.yaml
      JAVA_OPTS: "-Xms256m -Xmx512m -Djenkins.install.runSetupWizard=false"

- name: Install Docker CLI inside Jenkins container
  shell: |
    set -e
    docker exec -u 0 jenkins bash -lc 'apt-get update -y && (apt-get install -y docker.io || apt-get install -y docker-cli || apt-get install -y docker-ce-cli)'
    docker exec jenkins docker --version
  register: docker_cli_install
  changed_when: true

- name: Get docker group gid on host
  shell: "getent group docker | cut -d':' -f3"
  register: docker_gid
  changed_when: false

- name: Map docker group into container and add jenkins user to it
  shell: |
    set -e
    DOCKER_GID="{{ docker_gid.stdout }}"
    docker exec -u 0 jenkins bash -lc '
      set -e
      if getent group docker >/dev/null 2>&1; then
        groupmod -o -g '"$DOCKER_GID"' docker || true;
      else
        groupadd -g '"$DOCKER_GID"' docker || true;
      fi
      usermod -aG docker jenkins
    '
    # show membership
    docker exec jenkins id jenkins
  when: docker_gid.stdout | length > 0

- name: Wait until Jenkins container is running (not restarting)
  shell: |
    set -e
    docker inspect --format "{{'{{'}}.State.Running{{'}}'}} {{'{{'}}.State.Restarting{{'}}'}}" jenkins 2>/dev/null | grep -q "^true false$"
  register: jenkins_running
  retries: 30
  delay: 5
  until: jenkins_running.rc == 0
  changed_when: false

- name: Diagnostics when Jenkins is not healthy
  shell: |
    echo '--- docker ps:'
    docker ps -a --filter name=jenkins
    echo '--- inspect:'
    docker inspect jenkins | sed -n '1,120p'
    echo '--- last 200 logs:'
    docker logs --tail=200 jenkins | sed -n '1,200p'
  when: jenkins_running is failed
  register: jenkins_diag
  failed_when: false
  changed_when: false
  ignore_errors: true

- name: Show Jenkins diagnostics
  debug:
    var: jenkins_diag.stdout_lines
  when: jenkins_diag is defined

- name: Install plugins via CLI
  shell: docker exec jenkins jenkins-plugin-cli -f /config/plugins.txt
  register: plugin_cli
  retries: 8
  delay: 10
  until: plugin_cli.rc == 0

- name: Restart Jenkins to load plugins + JCasC
  docker_container:
    name: jenkins
    restart: yes

- name: Wait for Jenkins HTTP to respond
  shell: |
    for i in $(seq 1 60); do
      code=$(curl -s -m 3 -o /dev/null -w '%{http_code}' http://localhost:8080/login || true);
      if [ "$code" = "200" ]; then exit 0; fi; sleep 2;
    done; exit 1
  register: jenkins_http_ready
  retries: 1
  delay: 0
  changed_when: false

- name: Render RMIT-Store pipeline job XML (REST)
  copy:
    dest: /opt/jenkins/job-rmit-store.xml
    mode: '0644'
    content: |
      <flow-definition plugin="workflow-job">
        <description>CI/CD pipeline for RMIT Store</description>
        <keepDependencies>false</keepDependencies>
        <triggers>
          <com.cloudbees.jenkins.GitHubPushTrigger plugin="github"/>
        </triggers>
        <definition class="org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition" plugin="workflow-cps">
          <scm class="hudson.plugins.git.GitSCM" plugin="git">
            <userRemoteConfigs>
              <hudson.plugins.git.UserRemoteConfig>
                <url>{{ github_repo }}</url>
                <credentialsId>github-token</credentialsId>
              </hudson.plugins.git.UserRemoteConfig>
            </userRemoteConfigs>
            <branches>
              <hudson.plugins.git.BranchSpec><name>*/main</name></hudson.plugins.git.BranchSpec>
            </branches>
          </scm>
          <scriptPath>Jenkinsfile</scriptPath>
          <lightweight>true</lightweight>
        </definition>
      </flow-definition>

- name: Check if RMIT-Store job exists
  shell: |
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    curl -s -u "$ADMIN:$PASS" -o /dev/null -w '%{http_code}' http://localhost:8080/job/RMIT-Store/api/json || true
  register: job_exists
  changed_when: false

- name: Create RMIT-Store job via REST
  shell: |
    ADMIN="{{ jenkins_admin_user }}"; PASS="{{ jenkins_admin_password }}";
    CRUMB=$(curl -s -u "$ADMIN:$PASS" http://localhost:8080/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,":",//crumb));
    curl -s -u "$ADMIN:$PASS" -H "$CRUMB" -H 'Content-Type: application/xml' \
      -X POST --data-binary @/opt/jenkins/job-rmit-store.xml \
      'http://localhost:8080/createItem?name=RMIT-Store' || true
  when: job_exists.stdout != '200'
  changed_when: true

- name: Compute GitHub webhook URL
  set_fact:
    gh_webhook_url: "{{ jenkins_url_hint | regex_replace('/?$', '/') }}github-webhook/"

- name: List existing GitHub webhooks
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ (github_repo | regex_replace('.*/','')) }}/hooks"
    method: GET
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    return_content: true
  register: gh_hooks
  changed_when: false

- name: Check if webhook exists
  set_fact:
    gh_hook: "{{ (gh_hooks.json | selectattr('config.url','equalto', gh_webhook_url) | list | first) | default(None) }}"

- name: Ensure GitHub webhook exists (create if missing)
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ (github_repo | regex_replace('.*/','')) }}/hooks"
    method: POST
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    status_code: [201, 422]
    body_format: json
    body:
      name: web
      active: true
      events: [push]
      config:
        url: "{{ gh_webhook_url }}"
        content_type: json
        insecure_ssl: "0"
  register: gh_create

- name: Determine webhook id
  set_fact:
    gh_hook_id: "{{ (gh_hook.id | default('')) if (gh_hook is defined and gh_hook is not none) else (gh_create.json.id | default('')) }}"

- name: Ping webhook
  uri:
    url: "https://api.github.com/repos/{{ github_owner }}/{{ (github_repo | regex_replace('.*/','')) }}/hooks/{{ gh_hook_id }}/pings"
    method: POST
    headers:
      Authorization: "token {{ github_token }}"
      Accept: "application/vnd.github+json"
    status_code: 204
  changed_when: false
  when: gh_hook_id is defined and gh_hook_id | length > 0
